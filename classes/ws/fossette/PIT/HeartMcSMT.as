package ws.fossette.PIT{
	import ws.fossette.PIT.*;        import flash.display.*;    import flash.events.Event;    import flash.filters.DropShadowFilter;    import flash.filters.GlowFilter;    import flash.geom.Matrix;    import flash.geom.Rectangle;    import flash.geom.ColorTransform;    //public class HeartMcSMT extends MovieClip {
	public class HeartMcSMT extends Sprite {        private static var _bmdList:Array;        private static var _list:Vector.<HeartMcSMT> = new Vector.<HeartMcSMT>();        private static var _len:uint;                private var _x:Number;        private var _y:Number;        private var _rotation:Number;        private var _bmp:Bitmap;        private var _scale:Number;                public function HeartMcSMT() {            if ( !_bmdList ) {                _bmdList = new Array();                var mc:MovieClip = new BgSnow();                mc.filters = [ new GlowFilter( 0xffffff, 0.5, 20, 20, 4, 3 )]                var rect:Rectangle = mc.getBounds(this);                var size:Number = Math.sqrt( rect.right * rect.right + rect.bottom * rect.bottom ) + 30;                for ( var s:uint = 2; s <= 15; s++ ){                    _bmdList[s] = new Vector.<BitmapData>();                    var scale:Number = s / 10;                    for ( var i = 0; i < 360; i++ ) {                        var bmd:BitmapData = new BitmapData( size * 2 * scale + 1, size * 2 * scale + 1, true, 0 );                        var m:Matrix = new Matrix();                        m.scale( scale, scale );                        m.rotate( i * Math.PI / 180 );                        m.tx = size * scale;                        m.ty = size * scale;                        bmd.draw( mc, m );                        _bmdList[s].push( bmd );                    }                }            }            _bmp = addChild( new Bitmap() ) as Bitmap;            _scale = Math.max( 2, Math.round( Math.random() * 15 ) );            rotation = super.rotation;            x = 30 + Math.random() * 700;            y = -100 + 30 * Math.random();            _x = Math.max( 1, Math.round( 6 * Math.random() ) );            _y = Math.max( 1, Math.round( 6 * Math.random() ) );
			
			var cc:ColorTransform = new ColorTransform();
	cc.color = Math.random()*0x333333|0xFF0000;
	_bmp.transform.colorTransform=cc;
	_bmp.alpha = Math.random()*0.5+0.2;
            _list.push(this);            _len = _list.length;            addEventListener(Event.ENTER_FRAME, _enterFrame);        }                override public function get rotation():Number{ return _rotation; };        override public function set rotation( value:Number ):void{            _rotation = Math.round( value % 360 )            _bmp.bitmapData = _bmdList[_scale][_rotation];        }        public function _enterFrame(e:Event){         /*   x -= _x;            y += _y;
			*/
			x+= 0.2/(0.02*20+1)+0.3;
			y+= 1.5/(0.02*20+1);		
		
			            rotation ++;            if ( x < -80 || 480 < y ) {                x = Math.random() * 700;                y = -80;            }        }            }}